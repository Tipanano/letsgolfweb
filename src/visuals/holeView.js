// src/visuals/holeView.js
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js';
import { TextureLoader } from 'https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js'; // Import TextureLoader
import { createNoise2D } from 'https://esm.sh/simplex-noise'; // Import Simplex noise
import { scene, YARDS_TO_METERS } from './core.js'; // Import scene and conversion factor

let currentHoleObjects = []; // To keep track of objects added for the hole
let currentFlagPosition = null; // Store the flag position in meters (Vector3)
let currentGreenCenter = null; // Store the green center position in meters (Vector3)
let currentGreenRadius = null; // Store the green radius in meters (Number)
let flagstickPoleMesh = null; // Reference to the flagstick pole mesh
let flagClothMesh = null; // Reference to the flag cloth mesh

/**
 * Clears any previously drawn hole objects from the scene.
 */
export function clearHoleLayout() {
    if (!scene) return;
    currentHoleObjects.forEach(obj => {
        scene.remove(obj);
        if (obj.geometry) obj.geometry.dispose();
        if (obj.material) obj.material.dispose();
    });
    currentHoleObjects = [];
    // Reset flagstick references when clearing
    flagstickPoleMesh = null;
    flagClothMesh = null;
    console.log("Cleared previous hole layout visuals.");
}

/**
 * Draws the hole layout based on the provided data structure.
 * @param {object} holeLayout - The hole data generated by holeGenerator.js
 */
export function drawHoleLayout(holeLayout) {
    if (!scene || !holeLayout) {
        console.error("Scene not initialized or no hole layout provided for drawing.");
        return;
    }

    clearHoleLayout(); // Clear previous layout first
    currentFlagPosition = null; // Reset flag position on new draw
    currentGreenCenter = null; // Reset green data
    currentGreenRadius = null;
    console.log("Drawing hole layout:", holeLayout);

    const scale = YARDS_TO_METERS; // Use the conversion factor
    const textureLoader = new TextureLoader(); // Create texture loader instance

    // --- Draw Background (Out of Bounds - Draw first) ---
    if (holeLayout.background && holeLayout.background.vertices && holeLayout.background.surface) {
        const bgShape = new THREE.Shape();
        const firstBgPoint = holeLayout.background.vertices[0];
        // Use original Z
        bgShape.moveTo(firstBgPoint.x * scale, firstBgPoint.z * scale);
        for (let i = 1; i < holeLayout.background.vertices.length; i++) {
            const point = holeLayout.background.vertices[i];
             // Use original Z
            bgShape.lineTo(point.x * scale, point.z * scale);
        }
        bgShape.closePath();

        const bgGeometry = new THREE.ShapeGeometry(bgShape);
        // --- BEGIN Manual UV Calculation for Background ---
        bgGeometry.computeBoundingBox();
        const bgBbox = bgGeometry.boundingBox;
        if (bgBbox) {
            const positionAttribute = bgGeometry.attributes.position;
            const uvAttribute = new THREE.BufferAttribute(new Float32Array(positionAttribute.count * 2), 2);
            const sizeX = bgBbox.max.x - bgBbox.min.x;
            const sizeY = bgBbox.max.y - bgBbox.min.y;

            if (sizeX > 0 && sizeY > 0) {
                for (let i = 0; i < positionAttribute.count; i++) {
                    const x = positionAttribute.getX(i);
                    const y = positionAttribute.getY(i);
                    const u = (x - bgBbox.min.x) / sizeX;
                    const v = (y - bgBbox.min.y) / sizeY;
                    uvAttribute.setXY(i, u, v);
                }
                bgGeometry.setAttribute('uv', uvAttribute);
                console.log("Manually calculated UVs for background geometry.");
            } else {
                console.warn("Background geometry has zero size in X or Y dimension, cannot calculate UVs.");
            }
        } else {
            console.warn("Could not compute bounding box for background geometry.");
        }
        // --- END Manual UV Calculation for Background ---
        // Geometry is created using world coordinates, no centering needed.

        const bgSurface = holeLayout.background.surface;
        const bgMesh = new THREE.Mesh(bgGeometry); // Create mesh first
        bgMesh.rotation.x = Math.PI / 2; // Positive rotation
        bgMesh.position.set(0, bgSurface?.height ?? -0.01, 0); // Use defined height or fallback
        bgMesh.receiveShadow = true;

        // --- Background Material (Texture or Color) ---
        if (bgSurface && bgSurface.texturePath) {
            textureLoader.load(
                bgSurface.texturePath,
                (texture) => {
                    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                    const textureRepetitions = 5; // Example value, adjust as needed
                    texture.repeat.set(textureRepetitions, textureRepetitions);
                    bgMesh.material = new THREE.MeshStandardMaterial({
                        map: texture,
                        side: THREE.DoubleSide
                    });
                    bgMesh.material.needsUpdate = true;
                    console.log(`Texture ${bgSurface.texturePath} loaded and applied to background.`);
                },
                undefined,
                (err) => {
                    console.error(`Error loading background texture: ${bgSurface.texturePath}`, err);
                    bgMesh.material = new THREE.MeshStandardMaterial({
                        color: bgSurface?.color || '#8B4513', // Fallback color (SaddleBrown)
                        side: THREE.DoubleSide
                    });
                    bgMesh.material.needsUpdate = true;
                }
            );
        } else {
            bgMesh.material = new THREE.MeshStandardMaterial({
                color: bgSurface?.color || '#8B4513', // Fallback color
                side: THREE.DoubleSide
            });
            console.log("Applied color to background.");
        }

        scene.add(bgMesh);
        currentHoleObjects.push(bgMesh);
    }


    // --- Draw Rough (Draw on top of background) ---
    let roughGeometry = null; // Initialize as null
    // Reverted: Always create from vertices for now
    if (holeLayout.rough?.vertices && holeLayout.rough.vertices.length >= 3) {
        console.log("Creating rough shape from vertices.");
        const roughShapeFromVertices = new THREE.Shape();
        const firstRoughPoint = holeLayout.rough.vertices[0];
        roughShapeFromVertices.moveTo(firstRoughPoint.x * scale, firstRoughPoint.z * scale); // Use z here
        for (let i = 1; i < holeLayout.rough.vertices.length; i++) {
            const point = holeLayout.rough.vertices[i];
            roughShapeFromVertices.lineTo(point.x * scale, point.z * scale); // Use z here
        }
        roughShapeFromVertices.closePath();
        roughGeometry = new THREE.ShapeGeometry(roughShapeFromVertices);
    } else {
        console.warn("Rough definition missing or invalid. Cannot draw rough.");
        // roughGeometry remains null
    }


    if (roughGeometry) { // Proceed only if geometry was created
        // console.log("Rough geometry object is valid, proceeding to UV/Noise/Mesh creation.", roughGeometry); // Removed log
        // --- BEGIN Manual UV Calculation ---
        roughGeometry.computeBoundingBox(); // Ensure bounding box is computed (might have been done after scaling)
        const bbox = roughGeometry.boundingBox;
        if (bbox) { // Check if bounding box exists
            const positionAttribute = roughGeometry.attributes.position;
            const uvAttribute = new THREE.BufferAttribute(new Float32Array(positionAttribute.count * 2), 2);
            const sizeX = bbox.max.x - bbox.min.x;
            const sizeY = bbox.max.y - bbox.min.y; // Use Y size from XY plane

            if (sizeX > 0 && sizeY > 0) { // Avoid division by zero
                for (let i = 0; i < positionAttribute.count; i++) {
                    const x = positionAttribute.getX(i);
                    const y = positionAttribute.getY(i); // Use Y from ShapeGeometry's XY plane

                    const u = (x - bbox.min.x) / sizeX;
                    const v = (y - bbox.min.y) / sizeY;

                    uvAttribute.setXY(i, u, v);
                }
                roughGeometry.setAttribute('uv', uvAttribute);
                console.log("Manually calculated UVs for rough geometry.");
            } else {
                console.warn("Rough geometry has zero size in X or Y dimension, cannot calculate UVs.");
            }
        } else {
             console.warn("Could not compute bounding box for rough geometry.");
        }
        // --- END Manual UV Calculation ---

        // --- BEGIN Simplex Noise Vertex Colors for Variation ---
        const positionAttributeRough = roughGeometry.attributes.position;
        const vertexCountRough = positionAttributeRough.count;
        const colorsRough = new Float32Array(vertexCountRough * 3); // R, G, B
        const baseRoughColor = new THREE.Color(holeLayout.rough.surface?.color || '#228b22'); // Use surface color or fallback
        const noise2D = createNoise2D(); // Create a 2D noise function instance

        // --- Noise Parameters (Adjust these) ---
        const noiseScale = 0.001; // Smaller value = larger patches
        const variationStrength = 0.4; // Controls contrast (e.g., 0.2 means variation from 0.8 to 1.2)
        // --- End Noise Parameters ---

        for (let i = 0; i < vertexCountRough; i++) {
            // Use the correct coordinates based on how your ShapeGeometry is defined and rotated.
            // Shape is defined in XY plane before rotation:
            const x = positionAttributeRough.getX(i);
            const y = positionAttributeRough.getY(i);

            // Sample Simplex noise based on vertex position
            const noiseValue = noise2D(x * noiseScale, y * noiseScale); // Noise value between -1 and 1

            // Map noise value to a variation factor (e.g., 1.0 +/- variationStrength)
            const variation = 1.0 + noiseValue * variationStrength;

            // Clamp variation to avoid negative colors
            const clampedVariation = Math.max(0, variation);

            colorsRough[i * 3] = baseRoughColor.r * clampedVariation;
            colorsRough[i * 3 + 1] = baseRoughColor.g * clampedVariation;
            colorsRough[i * 3 + 2] = baseRoughColor.b * clampedVariation;
        }
        roughGeometry.setAttribute('color', new THREE.BufferAttribute(colorsRough, 3));
        console.log("Applied Simplex noise vertex colors to rough geometry.");
        // --- END Simplex Noise Variation ---

        // Geometry is created using world coordinates, no centering needed.

        // --- Rough Material (Texture or Color) ---
        const roughSurface = holeLayout.rough.surface;
        const roughMesh = new THREE.Mesh(roughGeometry); // Create mesh first
        roughMesh.rotation.x = Math.PI / 2; // Rotate ShapeGeometry like before
        roughMesh.position.set(0, roughSurface?.height ?? 0.0, 0); // Use defined height or fallback
        roughMesh.receiveShadow = true;

        if (roughSurface && roughSurface.texturePath) {
            textureLoader.load(
                roughSurface.texturePath,
                // onLoad callback
                (texture) => {
                    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                    // --- Simple Texture Repetition for Testing ---
                    const simpleRepetitions = 10; // Test value
                    texture.repeat.set(simpleRepetitions, simpleRepetitions);
                    console.log(`Rough Shape: Set simple texture repeat ${simpleRepetitions}x${simpleRepetitions}`);
                    // texture.needsUpdate = true; // Not needed when set before first render

                    roughMesh.material = new THREE.MeshStandardMaterial({ // Using StandardMaterial
                        map: texture,
                        side: THREE.DoubleSide,
                        vertexColors: true // <--- Enable vertex colors
                    });
                    roughMesh.material.needsUpdate = true; // Important: update material when texture loads
                    console.log(`Texture ${roughSurface.texturePath} loaded and applied to rough.`);
                },
                // onProgress callback (optional)
                undefined,
                // onError callback
                (err) => {
                    console.error(`Error loading rough texture: ${roughSurface.texturePath}`, err);
                    // Fallback to color on error
                    roughMesh.material = new THREE.MeshStandardMaterial({ // Using StandardMaterial
                        color: roughSurface?.color || '#228b22',
                        side: THREE.DoubleSide,
                        vertexColors: true // <--- Enable vertex colors
                    });
                    roughMesh.material.needsUpdate = true;
                }
            );
        } else {
            // Apply color immediately if no texture path
            roughMesh.material = new THREE.MeshStandardMaterial({ // Using StandardMaterial
                color: roughSurface?.color || '#228b22', // Fallback color
                side: THREE.DoubleSide,
                vertexColors: true // <--- Enable vertex colors
            });
            console.log("Applied color to rough.");
        }
        scene.add(roughMesh); // Add mesh to scene (material will be applied async if texture loads)
        currentHoleObjects.push(roughMesh);
    }


    // --- Draw Water Hazards (On top of rough, below bunkers/fairway/green) ---
    if (holeLayout.waterHazards && Array.isArray(holeLayout.waterHazards)) {
        holeLayout.waterHazards.forEach(water => {
            if (!water || !water.surface) return; // Skip invalid water hazards

            let waterGeometry;
            let waterMesh = new THREE.Mesh(); // Create mesh shell first
            waterMesh.receiveShadow = true; // Water can receive shadows
            const waterYOffset = water.surface.height ?? 0.002; // Use defined height or fallback
            const waterSurface = water.surface;

            if (water.type === 'circle' && water.center && water.radius) {
                const radiusMeters = water.radius * scale;
                const centerX = water.center.x * scale;
                const centerZ = water.center.z * scale;
                waterGeometry = new THREE.CircleGeometry(radiusMeters, 32);
                waterMesh.geometry = waterGeometry; // Assign geometry
                waterMesh.position.set(centerX, waterYOffset, centerZ);
                waterMesh.rotation.x = -Math.PI / 2;

            } else if (water.type === 'polygon' && water.vertices && water.vertices.length >= 3) {
                const waterShape = new THREE.Shape();
                const firstPoint = water.vertices[0];
                waterShape.moveTo(firstPoint.x * scale, firstPoint.z * scale);
                for (let i = 1; i < water.vertices.length; i++) {
                    const point = water.vertices[i];
                    waterShape.lineTo(point.x * scale, point.z * scale);
                }
                waterShape.closePath();
                waterGeometry = new THREE.ShapeGeometry(waterShape);
                 // --- BEGIN Manual UV Calculation for Polygon Water ---
                waterGeometry.computeBoundingBox();
                const waterBbox = waterGeometry.boundingBox;
                if (waterBbox) {
                    const positionAttribute = waterGeometry.attributes.position;
                    const uvAttribute = new THREE.BufferAttribute(new Float32Array(positionAttribute.count * 2), 2);
                    const sizeX = waterBbox.max.x - waterBbox.min.x;
                    const sizeY = waterBbox.max.y - waterBbox.min.y;

                    if (sizeX > 0 && sizeY > 0) {
                        for (let i = 0; i < positionAttribute.count; i++) {
                            const x = positionAttribute.getX(i);
                            const y = positionAttribute.getY(i);
                            const u = (x - waterBbox.min.x) / sizeX;
                            const v = (y - waterBbox.min.y) / sizeY;
                            uvAttribute.setXY(i, u, v);
                        }
                        waterGeometry.setAttribute('uv', uvAttribute);
                        // console.log("Manually calculated UVs for polygon water geometry."); // Optional: less verbose logging
                    } else {
                        console.warn("Polygon water geometry has zero size in X or Y dimension, cannot calculate UVs.");
                    }
                } else {
                    console.warn("Could not compute bounding box for polygon water geometry.");
                }
                // --- END Manual UV Calculation for Polygon Water ---
                waterMesh.geometry = waterGeometry; // Assign geometry
                waterMesh.position.set(0, waterYOffset, 0);
                waterMesh.rotation.x = Math.PI / 2;

            } else {
                console.warn("Skipping invalid water hazard definition:", water);
                return; // Skip this water hazard
            }

             // --- Water Material (Texture or Color) ---
            const waterMaterialOptions = {
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.85
            };

            if (waterSurface && waterSurface.texturePath) {
                textureLoader.load(
                    waterSurface.texturePath,
                    (texture) => {
                        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                        const textureRepetitions = 5; // Example value, adjust as needed
                        texture.repeat.set(textureRepetitions, textureRepetitions);
                        waterMesh.material = new THREE.MeshStandardMaterial({
                            ...waterMaterialOptions,
                            map: texture
                        });
                        waterMesh.material.needsUpdate = true;
                        console.log(`Texture ${waterSurface.texturePath} loaded and applied to water.`);
                    },
                    undefined,
                    (err) => {
                        console.error(`Error loading water texture: ${waterSurface.texturePath}`, err);
                        waterMesh.material = new THREE.MeshStandardMaterial({
                            ...waterMaterialOptions,
                            color: waterSurface?.color || '#ADD8E6' // Fallback color (LightBlue)
                        });
                        waterMesh.material.needsUpdate = true;
                    }
                );
            } else {
                waterMesh.material = new THREE.MeshStandardMaterial({
                     ...waterMaterialOptions,
                    color: waterSurface?.color || '#ADD8E6' // Fallback color
                });
                console.log("Applied color to water.");
            }


            scene.add(waterMesh);
            currentHoleObjects.push(waterMesh);
        });
    }

    // --- Draw Bunkers (On top of rough/water, below fairway/green) ---
    if (holeLayout.bunkers && Array.isArray(holeLayout.bunkers)) {
        holeLayout.bunkers.forEach(bunker => {
            if (!bunker || !bunker.surface) return; // Skip invalid bunkers

            // Initialize mesh first, material will be set later (async texture loading)
            let bunkerGeometry;
            let bunkerMesh = new THREE.Mesh(); // Create mesh shell
            bunkerMesh.receiveShadow = true;
            const bunkerYOffset = bunker.surface.height ?? 0.005; // Use defined height or fallback
            const bunkerSurface = bunker.surface; // Reference surface data

            if (bunker.type === 'circle' && bunker.center && bunker.radius) {
                const radiusMeters = bunker.radius * scale;
                const centerX = bunker.center.x * scale;
                const centerZ = bunker.center.z * scale;
                bunkerGeometry = new THREE.CircleGeometry(radiusMeters, 32);
                bunkerMesh.geometry = bunkerGeometry; // Assign geometry
                bunkerMesh.position.set(centerX, bunkerYOffset, centerZ);
                bunkerMesh.rotation.x = -Math.PI / 2;

            } else if (bunker.type === 'polygon' && bunker.vertices && bunker.vertices.length >= 3) {
                const bunkerShape = new THREE.Shape();
                const firstPoint = bunker.vertices[0];
                bunkerShape.moveTo(firstPoint.x * scale, firstPoint.z * scale);
                for (let i = 1; i < bunker.vertices.length; i++) {
                    const point = bunker.vertices[i];
                    bunkerShape.lineTo(point.x * scale, point.z * scale);
                }
                bunkerShape.closePath();
                bunkerGeometry = new THREE.ShapeGeometry(bunkerShape);
                // --- BEGIN Manual UV Calculation for Polygon Bunker ---
                bunkerGeometry.computeBoundingBox();
                const bunkerBbox = bunkerGeometry.boundingBox;
                if (bunkerBbox) {
                    const positionAttribute = bunkerGeometry.attributes.position;
                    const uvAttribute = new THREE.BufferAttribute(new Float32Array(positionAttribute.count * 2), 2);
                    const sizeX = bunkerBbox.max.x - bunkerBbox.min.x;
                    const sizeY = bunkerBbox.max.y - bunkerBbox.min.y;

                    if (sizeX > 0 && sizeY > 0) {
                        for (let i = 0; i < positionAttribute.count; i++) {
                            const x = positionAttribute.getX(i);
                            const y = positionAttribute.getY(i);
                            const u = (x - bunkerBbox.min.x) / sizeX;
                            const v = (y - bunkerBbox.min.y) / sizeY;
                            uvAttribute.setXY(i, u, v);
                        }
                        bunkerGeometry.setAttribute('uv', uvAttribute);
                         // console.log("Manually calculated UVs for polygon bunker geometry."); // Optional: less verbose logging
                    } else {
                        console.warn("Polygon bunker geometry has zero size in X or Y dimension, cannot calculate UVs.");
                    }
                } else {
                    console.warn("Could not compute bounding box for polygon bunker geometry.");
                }
                 // --- END Manual UV Calculation for Polygon Bunker ---
                bunkerMesh.geometry = bunkerGeometry; // Assign geometry
                bunkerMesh.position.set(0, bunkerYOffset, 0);
                bunkerMesh.rotation.x = Math.PI / 2;

            } else {
                console.warn("Skipping invalid bunker definition:", bunker);
                return; // Skip this bunker
            }

            // --- Bunker Material (Texture or Color) ---
            if (bunkerSurface && bunkerSurface.texturePath) {
                textureLoader.load(
                    bunkerSurface.texturePath,
                    // onLoad callback
                    (texture) => {
                        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                        // Adjust repetition as needed, similar to fairway/green
                        const textureRepetitions = 8; // Example value, adjust for desired look
                        texture.repeat.set(textureRepetitions, textureRepetitions);

                        bunkerMesh.material = new THREE.MeshStandardMaterial({
                            map: texture,
                            side: THREE.DoubleSide
                        });
                        bunkerMesh.material.needsUpdate = true;
                        console.log(`Texture ${bunkerSurface.texturePath} loaded and applied to bunker.`);
                    },
                    // onProgress callback (optional)
                    undefined,
                    // onError callback
                    (err) => {
                        console.error(`Error loading bunker texture: ${bunkerSurface.texturePath}`, err);
                        // Fallback to color on error
                        bunkerMesh.material = new THREE.MeshStandardMaterial({
                            color: bunkerSurface?.color || '#D2B48C', // Fallback color (Tan)
                            side: THREE.DoubleSide
                        });
                        bunkerMesh.material.needsUpdate = true;
                    }
                );
            } else {
                // Apply color immediately if no texture path
                bunkerMesh.material = new THREE.MeshStandardMaterial({
                    color: bunkerSurface?.color || '#D2B48C', // Fallback color (Tan)
                    side: THREE.DoubleSide
                });
                console.log("Applied color to bunker.");
            }

            scene.add(bunkerMesh); // Add mesh to scene (material might be applied async)
            currentHoleObjects.push(bunkerMesh);
        });
    }


    // --- Draw Fairway (On top of rough/water/bunkers) ---
    let fairwayGeometry = null; // Initialize as null
     // Reverted: Always create from vertices for now
    if (holeLayout.fairway?.vertices && holeLayout.fairway.vertices.length >= 3) {
        console.log("Creating fairway shape from vertices.");
        const fairwayShapeFromVertices = new THREE.Shape();
        const firstPoint = holeLayout.fairway.vertices[0];
        fairwayShapeFromVertices.moveTo(firstPoint.x * scale, firstPoint.z * scale); // Use z
        for (let i = 1; i < holeLayout.fairway.vertices.length; i++) {
            const point = holeLayout.fairway.vertices[i];
            fairwayShapeFromVertices.lineTo(point.x * scale, point.z * scale); // Use z
        }
        fairwayShapeFromVertices.closePath();
        fairwayGeometry = new THREE.ShapeGeometry(fairwayShapeFromVertices);
    } else {
         console.warn("Fairway definition missing or invalid. Cannot draw fairway.");
         // fairwayGeometry remains null
    }

    if(fairwayGeometry) { // Proceed only if geometry was created
        // console.log("Fairway geometry object is valid, proceeding to UV/Mesh creation.", fairwayGeometry); // Removed log
        // --- BEGIN Manual UV Calculation for Fairway ---
        fairwayGeometry.computeBoundingBox(); // Ensure bounding box is computed (might have been done after scaling)
        const fairwayBbox = fairwayGeometry.boundingBox;
        if (fairwayBbox) {
            const positionAttribute = fairwayGeometry.attributes.position;
            const uvAttribute = new THREE.BufferAttribute(new Float32Array(positionAttribute.count * 2), 2);
            const sizeX = fairwayBbox.max.x - fairwayBbox.min.x;
            const sizeY = fairwayBbox.max.y - fairwayBbox.min.y;

            if (sizeX > 0 && sizeY > 0) {
                for (let i = 0; i < positionAttribute.count; i++) {
                    const x = positionAttribute.getX(i);
                    const y = positionAttribute.getY(i);
                    const u = (x - fairwayBbox.min.x) / sizeX;
                    const v = (y - fairwayBbox.min.y) / sizeY;
                    uvAttribute.setXY(i, u, v);
                }
                fairwayGeometry.setAttribute('uv', uvAttribute);
                console.log("Manually calculated UVs for fairway geometry.");
            } else {
                console.warn("Fairway geometry has zero size in X or Y dimension, cannot calculate UVs.");
            }
        } else {
            console.warn("Could not compute bounding box for fairway geometry.");
        }
        // --- END Manual UV Calculation for Fairway ---
        // Geometry is created using world coordinates, no centering needed.

        // --- Fairway Material (Texture or Color) ---
        const fairwaySurface = holeLayout.fairway.surface;
        const fairwayMesh = new THREE.Mesh(fairwayGeometry); // Create mesh first
        fairwayMesh.rotation.x = Math.PI / 2; // Positive rotation
        fairwayMesh.position.set(0, fairwaySurface?.height ?? 0.01, 0); // Use defined height or fallback
        fairwayMesh.receiveShadow = true;

        if (fairwaySurface && fairwaySurface.texturePath) {
             textureLoader.load(
                fairwaySurface.texturePath,
                // onLoad callback
                (texture) => {
                    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                    // Removed old repetition logic - manual UVs handle mapping
                    // const textureWorldSize = 10;
                    // fairwayGeometry.computeBoundingBox(); // Already computed for UVs
                    // const size = fairwayGeometry.boundingBox.getSize(new THREE.Vector3());
                    // texture.repeat.set(size.x / textureWorldSize, size.y / textureWorldSize);
                    const textureRepetitions = 15; // Adjust this value to control tiling density
                    texture.repeat.set(textureRepetitions, textureRepetitions);


                    fairwayMesh.material = new THREE.MeshStandardMaterial({ // Changed to StandardMaterial
                        map: texture,
                        side: THREE.DoubleSide
                    });
                    fairwayMesh.material.needsUpdate = true;
                    console.log(`Texture ${fairwaySurface.texturePath} loaded and applied to fairway.`);
                },
                 // onProgress callback (optional)
                undefined,
                // onError callback
                (err) => {
                    console.error(`Error loading fairway texture: ${fairwaySurface.texturePath}`, err);
                    // Fallback to color on error
                    fairwayMesh.material = new THREE.MeshStandardMaterial({ // Changed to StandardMaterial
                        color: fairwaySurface?.color || '#5DBB5D',
                        side: THREE.DoubleSide
                    });
                    fairwayMesh.material.needsUpdate = true;
                }
            );
        } else {
             // Apply color immediately if no texture path
            fairwayMesh.material = new THREE.MeshStandardMaterial({ // Changed to StandardMaterial
                color: fairwaySurface?.color || '#5DBB5D', // Fallback color
                side: THREE.DoubleSide
            });
            console.log("Applied color to fairway.");
        }
        scene.add(fairwayMesh); // Add mesh to scene
        currentHoleObjects.push(fairwayMesh);
    }

    // --- Draw Green --- (Now uses polygon logic)
    if (holeLayout.green && holeLayout.green.type === 'polygon' && holeLayout.green.vertices && holeLayout.green.vertices.length >= 3 && holeLayout.green.surface) {
        const greenHeight = holeLayout.green.surface.height ?? 0.02; // Use defined height or fallback

        const greenShape = new THREE.Shape();
        const firstPoint = holeLayout.green.vertices[0];
        greenShape.moveTo(firstPoint.x * scale, firstPoint.z * scale);
        for (let i = 1; i < holeLayout.green.vertices.length; i++) {
            const point = holeLayout.green.vertices[i];
            greenShape.lineTo(point.x * scale, point.z * scale);
        }
        greenShape.closePath();

        const greenGeometry = new THREE.ShapeGeometry(greenShape);
        // --- BEGIN Manual UV Calculation for Green ---
        greenGeometry.computeBoundingBox();
        const greenBbox = greenGeometry.boundingBox;
        if (greenBbox) {
            const positionAttribute = greenGeometry.attributes.position;
            const uvAttribute = new THREE.BufferAttribute(new Float32Array(positionAttribute.count * 2), 2);
            const sizeX = greenBbox.max.x - greenBbox.min.x;
            const sizeY = greenBbox.max.y - greenBbox.min.y;

            if (sizeX > 0 && sizeY > 0) {
                for (let i = 0; i < positionAttribute.count; i++) {
                    const x = positionAttribute.getX(i);
                    const y = positionAttribute.getY(i);
                    const u = (x - greenBbox.min.x) / sizeX;
                    const v = (y - greenBbox.min.y) / sizeY;
                    uvAttribute.setXY(i, u, v);
                }
                greenGeometry.setAttribute('uv', uvAttribute);
                console.log("Manually calculated UVs for green geometry.");
            } else {
                console.warn("Green geometry has zero size in X or Y dimension, cannot calculate UVs.");
            }
        } else {
            console.warn("Could not compute bounding box for green geometry.");
        }
        // --- END Manual UV Calculation for Green ---
        // --- Green Material (Texture or Color) ---
        const greenSurface = holeLayout.green.surface;
        const greenMesh = new THREE.Mesh(greenGeometry); // Create mesh first
        greenMesh.rotation.x = Math.PI / 2; // Rotate polygon to lay flat like fairway/rough
        greenMesh.position.set(0, greenHeight, 0); // Position mesh using surface height
        greenMesh.receiveShadow = true;

         if (greenSurface && greenSurface.texturePath) {
             textureLoader.load(
                greenSurface.texturePath,
                // onLoad callback
                (texture) => {
                    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                    // Removed old repetition logic - manual UVs handle mapping
                    // const textureWorldSize = 4;
                    // greenGeometry.computeBoundingBox(); // Already computed for UVs
                    // const size = greenGeometry.boundingBox.getSize(new THREE.Vector3());
                    // texture.repeat.set(size.x / textureWorldSize, size.y / textureWorldSize);
                    const textureRepetitions = 10; // Adjust this value to control tiling density
                    texture.repeat.set(textureRepetitions, textureRepetitions);


                    greenMesh.material = new THREE.MeshStandardMaterial({ // Changed to StandardMaterial
                        map: texture,
                        side: THREE.DoubleSide
                    });
                    greenMesh.material.needsUpdate = true;
                    console.log(`Texture ${greenSurface.texturePath} loaded and applied to green.`);
                },
                 // onProgress callback (optional)
                undefined,
                // onError callback
                (err) => {
                    console.error(`Error loading green texture: ${greenSurface.texturePath}`, err);
                    // Fallback to color on error
                    greenMesh.material = new THREE.MeshStandardMaterial({ // Changed to StandardMaterial
                        color: greenSurface?.color || '#3A9A3A',
                        side: THREE.DoubleSide
                    });
                    greenMesh.material.needsUpdate = true;
                }
            );
        } else {
             // Apply color immediately if no texture path
            greenMesh.material = new THREE.MeshStandardMaterial({ // Changed to StandardMaterial
                color: greenSurface?.color || '#3A9A3A', // Fallback color
                side: THREE.DoubleSide
            });
            console.log("Applied color to green.");
        }
        scene.add(greenMesh); // Add mesh to scene
        currentHoleObjects.push(greenMesh);

        // TODO: Revisit how to store green center/radius for polygon shapes if needed later
        // For now, reset them as the old circle logic is gone.
        currentGreenCenter = null;
        currentGreenRadius = null;
        console.log(`Drawn polygon green at height ${greenHeight.toFixed(3)}`);

    } else if (holeLayout.green && holeLayout.green.center && holeLayout.green.radius) {
         // Fallback for old circle definition (optional, can be removed later)
         console.warn("Drawing green using legacy circle definition.");
         const greenRadiusMeters = holeLayout.green.radius * scale;
         const greenCenterX = holeLayout.green.center.x * scale;
         const greenCenterZ = holeLayout.green.center.z * scale;
         const greenHeight = holeLayout.green.surface?.height ?? 0.02;
         const greenGeometry = new THREE.CircleGeometry(greenRadiusMeters, 64);
         const greenMaterial = new THREE.MeshLambertMaterial({ color: holeLayout.green.surface?.color || '#3A9A3A', side: THREE.DoubleSide });
         const greenMesh = new THREE.Mesh(greenGeometry, greenMaterial);
         greenMesh.position.set(greenCenterX, greenHeight, greenCenterZ);
         greenMesh.rotation.x = -Math.PI / 2;
         greenMesh.receiveShadow = true;
         scene.add(greenMesh);
         currentHoleObjects.push(greenMesh);
         currentGreenCenter = new THREE.Vector3(greenCenterX, greenHeight, greenCenterZ);
         currentGreenRadius = greenRadiusMeters;
    } else {
        console.warn("Green definition is missing or invalid.");
    }

     // --- Draw Tee Box --- (Simple rectangle for now)
     if (holeLayout.tee && holeLayout.tee.center && holeLayout.tee.surface) {
        const teeWidth = holeLayout.tee.width * scale;
        const teeDepth = holeLayout.tee.depth * scale;
        const teeHeight = holeLayout.tee.surface.height ?? 0.03; // Use defined height or fallback

        const teeGeometry = new THREE.PlaneGeometry(teeWidth, teeDepth);
        const teeMaterial = new THREE.MeshLambertMaterial({ // Use Lambert
            color: holeLayout.tee.surface.color, // Use specified surface color
            side: THREE.DoubleSide
        });
        const teeMesh = new THREE.Mesh(teeGeometry, teeMaterial);
        teeMesh.position.set(
            holeLayout.tee.center.x * scale,
            teeHeight, // Use defined height
            holeLayout.tee.center.z * scale
        );
        teeMesh.rotation.x = -Math.PI / 2;
        teeMesh.receiveShadow = true; // Tee should also receive shadows
        scene.add(teeMesh);
        currentHoleObjects.push(teeMesh);
    }


    // --- Draw Flagstick ---
    if (holeLayout.flagPosition) {
        const flagHeight = 2.5; // Meters
        const flagRadius = 0.05; // Meters
        const flagGeometry = new THREE.CylinderGeometry(flagRadius, flagRadius, flagHeight, 8);
        const flagMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff }); // White pole
        flagstickPoleMesh = new THREE.Mesh(flagGeometry, flagMaterial); // Assign to module variable
        flagstickPoleMesh.name = "FlagstickPole"; // Optional: Add name for debugging
        flagstickPoleMesh.position.set(
            holeLayout.flagPosition.x * scale,
            flagHeight / 2, // Position base at ground level (Y=0) relative to its center
            holeLayout.flagPosition.z * scale
        );
        flagstickPoleMesh.castShadow = true;
        scene.add(flagstickPoleMesh);
        currentHoleObjects.push(flagstickPoleMesh);

        // Store the flag position (base of the stick)
        currentFlagPosition = new THREE.Vector3(
            holeLayout.flagPosition.x * scale,
            0, // Assuming flag base is at y=0 world coordinate
            holeLayout.flagPosition.z * scale
        );
        console.log("Stored flag position (meters):", currentFlagPosition);


        // Optional: Add a little flag cloth
        const flagClothGeometry = new THREE.PlaneGeometry(0.5, 0.3);
        const flagClothMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide }); // Red flag
        flagClothMesh = new THREE.Mesh(flagClothGeometry, flagClothMaterial); // Assign to module variable
        flagClothMesh.name = "FlagCloth"; // Optional: Add name for debugging
        // Position relative to flagstick top
        flagClothMesh.position.set(
            flagstickPoleMesh.position.x + 0.25, // Offset slightly from pole
            flagstickPoleMesh.position.y + flagHeight / 2 - 0.15, // Near the top
            flagstickPoleMesh.position.z
        );
        scene.add(flagClothMesh);
        currentHoleObjects.push(flagClothMesh);

        // --- Draw the Hole Cup ---
        const HOLE_RADIUS_METERS = 0.108 / 2; // Regulation hole diameter is 4.25 inches (0.108m)
        const holeDepth = 0.1; // Depth for the visual cup (meters)
        const holeGeometry = new THREE.CylinderGeometry(HOLE_RADIUS_METERS, HOLE_RADIUS_METERS, holeDepth, 16);
        const holeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 }); // Black
        const holeMesh = new THREE.Mesh(holeGeometry, holeMaterial);
        holeMesh.renderOrder = 1; // Draw hole *after* the green

        // Position the hole centered at the flag position, top edge slightly below green surface
        const greenSurfaceY = currentGreenCenter ? currentGreenCenter.y : (holeLayout.green?.surface?.height ?? 0.02); // Get green height
        const holeTopEdgeY = greenSurfaceY + 0.05; // Place top slightly below green surface
        const holeCenterY = holeTopEdgeY - (holeDepth / 2); // Calculate center Y

        holeMesh.position.set(
            currentFlagPosition.x,
            holeCenterY, // Position cylinder center
            currentFlagPosition.z
        );
        // No rotation needed as cylinder is upright

        scene.add(holeMesh);
        currentHoleObjects.push(holeMesh);
    }

    console.log("Finished drawing hole layout. Added objects:", currentHoleObjects.length);
}

/**
 * Returns the stored position of the flagstick base in world coordinates (meters).
 * @returns {THREE.Vector3 | null} The flag position or null if not set.
 */
export function getFlagPosition() {
    return currentFlagPosition;
}

/**
 * Returns the stored center position of the green in world coordinates (meters).
 * @returns {THREE.Vector3 | null} The green center position or null if not set.
 */
export function getGreenCenter() {
    return currentGreenCenter;
}

/**
 * Returns the stored radius of the green in meters.
 * @returns {number | null} The green radius or null if not set.
 */
export function getGreenRadius() {
    return currentGreenRadius;
}

/**
 * Sets the visibility of the flagstick pole and cloth.
 * @param {boolean} visible - True to show, false to hide.
 */
export function setFlagstickVisibility(visible) {
    if (flagstickPoleMesh) {
        flagstickPoleMesh.visible = visible;
    }
    if (flagClothMesh) {
        flagClothMesh.visible = visible;
    }
    console.log(`Flagstick visibility set to: ${visible}`);
}
