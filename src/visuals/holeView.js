// src/visuals/holeView.js
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js';
import { scene, YARDS_TO_METERS } from './core.js'; // Import scene and conversion factor

let currentHoleObjects = []; // To keep track of objects added for the hole
let currentFlagPosition = null; // Store the flag position in meters (Vector3)
let currentGreenCenter = null; // Store the green center position in meters (Vector3)
let currentGreenRadius = null; // Store the green radius in meters (Number)

/**
 * Clears any previously drawn hole objects from the scene.
 */
export function clearHoleLayout() {
    if (!scene) return;
    currentHoleObjects.forEach(obj => {
        scene.remove(obj);
        if (obj.geometry) obj.geometry.dispose();
        if (obj.material) obj.material.dispose();
    });
    currentHoleObjects = [];
    console.log("Cleared previous hole layout visuals.");
}

/**
 * Draws the hole layout based on the provided data structure.
 * @param {object} holeLayout - The hole data generated by holeGenerator.js
 */
export function drawHoleLayout(holeLayout) {
    if (!scene || !holeLayout) {
        console.error("Scene not initialized or no hole layout provided for drawing.");
        return;
    }

    clearHoleLayout(); // Clear previous layout first
    currentFlagPosition = null; // Reset flag position on new draw
    currentGreenCenter = null; // Reset green data
    currentGreenRadius = null;
    console.log("Drawing hole layout:", holeLayout);

    const scale = YARDS_TO_METERS; // Use the conversion factor

    // --- Draw Background (Out of Bounds - Draw first) ---
    if (holeLayout.background && holeLayout.background.vertices && holeLayout.background.surface) {
        const bgShape = new THREE.Shape();
        const firstBgPoint = holeLayout.background.vertices[0];
        // Use original Z
        bgShape.moveTo(firstBgPoint.x * scale, firstBgPoint.z * scale);
        for (let i = 1; i < holeLayout.background.vertices.length; i++) {
            const point = holeLayout.background.vertices[i];
             // Use original Z
            bgShape.lineTo(point.x * scale, point.z * scale);
        }
        bgShape.closePath();

        const bgGeometry = new THREE.ShapeGeometry(bgShape);
        // Geometry is created using world coordinates, no centering needed.

        const bgMaterial = new THREE.MeshLambertMaterial({
            color: holeLayout.background.surface.color,
            side: THREE.DoubleSide
        });
        const bgMesh = new THREE.Mesh(bgGeometry, bgMaterial);
        bgMesh.rotation.x = Math.PI / 2; // Positive rotation
        // Position mesh using surface height
        bgMesh.position.set(0, holeLayout.background.surface.height ?? -0.01, 0); // Use defined height or fallback
        bgMesh.receiveShadow = true; // Should still receive shadows
        scene.add(bgMesh);
        currentHoleObjects.push(bgMesh);
    }


    // --- Draw Rough (Draw on top of background) ---
    if (holeLayout.rough && holeLayout.rough.vertices && holeLayout.rough.surface) {
        // Define shape in XY plane (using Z as Y)
        const roughShape = new THREE.Shape();
        const firstRoughPoint = holeLayout.rough.vertices[0];
        // Use original Z
        roughShape.moveTo(firstRoughPoint.x * scale, firstRoughPoint.z * scale);

        for (let i = 1; i < holeLayout.rough.vertices.length; i++) {
            const point = holeLayout.rough.vertices[i];
             // Use original Z
            roughShape.lineTo(point.x * scale, point.z * scale);
        }
        roughShape.closePath();

        const roughGeometry = new THREE.ShapeGeometry(roughShape);
        // Geometry is created using world coordinates (with X negated), no centering needed.

        const roughMaterial = new THREE.MeshLambertMaterial({
            color: holeLayout.rough.surface.color,
            side: THREE.DoubleSide
        });
        const roughMesh = new THREE.Mesh(roughGeometry, roughMaterial);
        roughMesh.rotation.x = Math.PI / 2; // Positive rotation
        // Position mesh using surface height
        roughMesh.position.set(0, holeLayout.rough.surface.height ?? 0.0, 0); // Use defined height or fallback
        roughMesh.receiveShadow = true;
        scene.add(roughMesh);
        currentHoleObjects.push(roughMesh);
    }


    // --- Draw Water Hazards (On top of rough, below bunkers/fairway/green) ---
    if (holeLayout.waterHazards && Array.isArray(holeLayout.waterHazards)) {
        holeLayout.waterHazards.forEach(water => {
            if (!water || !water.surface) return; // Skip invalid water hazards

            const waterMaterial = new THREE.MeshLambertMaterial({
                color: water.surface.color,
                side: THREE.DoubleSide,
                transparent: true, // Make water slightly transparent
                opacity: 0.85
            });
            let waterGeometry;
            let waterMesh;
            const waterYOffset = water.surface.height ?? 0.002; // Use defined height or fallback

            if (water.type === 'circle' && water.center && water.radius) {
                const radiusMeters = water.radius * scale;
                const centerX = water.center.x * scale;
                const centerZ = water.center.z * scale;
                waterGeometry = new THREE.CircleGeometry(radiusMeters, 32);
                waterMesh = new THREE.Mesh(waterGeometry, waterMaterial);
                waterMesh.position.set(centerX, waterYOffset, centerZ);
                waterMesh.rotation.x = -Math.PI / 2;

            } else if (water.type === 'polygon' && water.vertices && water.vertices.length >= 3) {
                const waterShape = new THREE.Shape();
                const firstPoint = water.vertices[0];
                waterShape.moveTo(firstPoint.x * scale, firstPoint.z * scale);
                for (let i = 1; i < water.vertices.length; i++) {
                    const point = water.vertices[i];
                    waterShape.lineTo(point.x * scale, point.z * scale);
                }
                waterShape.closePath();
                waterGeometry = new THREE.ShapeGeometry(waterShape);
                waterMesh = new THREE.Mesh(waterGeometry, waterMaterial);
                waterMesh.position.set(0, waterYOffset, 0);
                waterMesh.rotation.x = Math.PI / 2;

            } else {
                console.warn("Skipping invalid water hazard definition:", water);
                return; // Skip this water hazard
            }

            waterMesh.receiveShadow = true; // Water can receive shadows
            scene.add(waterMesh);
            currentHoleObjects.push(waterMesh);
        });
    }

    // --- Draw Bunkers (On top of rough/water, below fairway/green) ---
    if (holeLayout.bunkers && Array.isArray(holeLayout.bunkers)) {
        holeLayout.bunkers.forEach(bunker => {
            if (!bunker || !bunker.surface) return; // Skip invalid bunkers

            const bunkerMaterial = new THREE.MeshLambertMaterial({
                color: bunker.surface.color,
                side: THREE.DoubleSide
            });
            let bunkerGeometry;
            let bunkerMesh;
            const bunkerYOffset = bunker.surface.height ?? 0.005; // Use defined height or fallback

            if (bunker.type === 'circle' && bunker.center && bunker.radius) {
                const radiusMeters = bunker.radius * scale;
                const centerX = bunker.center.x * scale;
                const centerZ = bunker.center.z * scale;
                bunkerGeometry = new THREE.CircleGeometry(radiusMeters, 32); // Use 32 segments for smoother circle
                bunkerMesh = new THREE.Mesh(bunkerGeometry, bunkerMaterial);
                bunkerMesh.position.set(centerX, bunkerYOffset, centerZ);
                bunkerMesh.rotation.x = -Math.PI / 2; // Rotate to lay flat

            } else if (bunker.type === 'polygon' && bunker.vertices && bunker.vertices.length >= 3) {
                const bunkerShape = new THREE.Shape();
                const firstPoint = bunker.vertices[0];
                bunkerShape.moveTo(firstPoint.x * scale, firstPoint.z * scale);
                for (let i = 1; i < bunker.vertices.length; i++) {
                    const point = bunker.vertices[i];
                    bunkerShape.lineTo(point.x * scale, point.z * scale);
                }
                bunkerShape.closePath();
                bunkerGeometry = new THREE.ShapeGeometry(bunkerShape);
                bunkerMesh = new THREE.Mesh(bunkerGeometry, bunkerMaterial);
                bunkerMesh.position.set(0, bunkerYOffset, 0); // Position at origin, geometry defines shape location
                bunkerMesh.rotation.x = Math.PI / 2; // Rotate to lay flat (like fairway/rough)

            } else {
                console.warn("Skipping invalid bunker definition:", bunker);
                return; // Skip this bunker
            }

            bunkerMesh.receiveShadow = true;
            scene.add(bunkerMesh);
            currentHoleObjects.push(bunkerMesh);
        });
    }


    // --- Draw Fairway (On top of rough/water/bunkers) ---
    if (holeLayout.fairway && holeLayout.fairway.vertices && holeLayout.fairway.surface) {
        // Define shape in XY plane (using Z as Y)
        const fairwayShape = new THREE.Shape();
        const firstPoint = holeLayout.fairway.vertices[0];
        // Use original coordinates
        fairwayShape.moveTo(firstPoint.x * scale, firstPoint.z * scale);
        for (let i = 1; i < holeLayout.fairway.vertices.length; i++) {
            const point = holeLayout.fairway.vertices[i];
             // Use original coordinates
            fairwayShape.lineTo(point.x * scale, point.z * scale);
        }
        fairwayShape.closePath();

        const fairwayGeometry = new THREE.ShapeGeometry(fairwayShape);
        // Geometry is created using world coordinates, no centering needed.

        const fairwayMaterial = new THREE.MeshLambertMaterial({
            color: holeLayout.fairway.surface.color,
            side: THREE.DoubleSide
        });
        const fairwayMesh = new THREE.Mesh(fairwayGeometry, fairwayMaterial);
        fairwayMesh.rotation.x = Math.PI / 2; // Positive rotation
        // Position mesh using surface height
        fairwayMesh.position.set(0, holeLayout.fairway.surface.height ?? 0.01, 0); // Use defined height or fallback
        fairwayMesh.receiveShadow = true;
        scene.add(fairwayMesh);
        currentHoleObjects.push(fairwayMesh);
    }

    // --- Draw Green --- (Now uses polygon logic)
    if (holeLayout.green && holeLayout.green.type === 'polygon' && holeLayout.green.vertices && holeLayout.green.vertices.length >= 3 && holeLayout.green.surface) {
        const greenHeight = holeLayout.green.surface.height ?? 0.02; // Use defined height or fallback

        const greenShape = new THREE.Shape();
        const firstPoint = holeLayout.green.vertices[0];
        greenShape.moveTo(firstPoint.x * scale, firstPoint.z * scale);
        for (let i = 1; i < holeLayout.green.vertices.length; i++) {
            const point = holeLayout.green.vertices[i];
            greenShape.lineTo(point.x * scale, point.z * scale);
        }
        greenShape.closePath();

        const greenGeometry = new THREE.ShapeGeometry(greenShape);
        const greenMaterial = new THREE.MeshLambertMaterial({
            color: holeLayout.green.surface.color,
            side: THREE.DoubleSide
        });
        const greenMesh = new THREE.Mesh(greenGeometry, greenMaterial);
        greenMesh.rotation.x = Math.PI / 2; // Rotate polygon to lay flat like fairway/rough
        greenMesh.position.set(0, greenHeight, 0); // Position mesh using surface height
        greenMesh.receiveShadow = true;
        scene.add(greenMesh);
        currentHoleObjects.push(greenMesh);

        // TODO: Revisit how to store green center/radius for polygon shapes if needed later
        // For now, reset them as the old circle logic is gone.
        currentGreenCenter = null;
        currentGreenRadius = null;
        console.log(`Drawn polygon green at height ${greenHeight.toFixed(3)}`);

    } else if (holeLayout.green && holeLayout.green.center && holeLayout.green.radius) {
         // Fallback for old circle definition (optional, can be removed later)
         console.warn("Drawing green using legacy circle definition.");
         const greenRadiusMeters = holeLayout.green.radius * scale;
         const greenCenterX = holeLayout.green.center.x * scale;
         const greenCenterZ = holeLayout.green.center.z * scale;
         const greenHeight = holeLayout.green.surface?.height ?? 0.02;
         const greenGeometry = new THREE.CircleGeometry(greenRadiusMeters, 64);
         const greenMaterial = new THREE.MeshLambertMaterial({ color: holeLayout.green.surface?.color || '#3A9A3A', side: THREE.DoubleSide });
         const greenMesh = new THREE.Mesh(greenGeometry, greenMaterial);
         greenMesh.position.set(greenCenterX, greenHeight, greenCenterZ);
         greenMesh.rotation.x = -Math.PI / 2;
         greenMesh.receiveShadow = true;
         scene.add(greenMesh);
         currentHoleObjects.push(greenMesh);
         currentGreenCenter = new THREE.Vector3(greenCenterX, greenHeight, greenCenterZ);
         currentGreenRadius = greenRadiusMeters;
    } else {
        console.warn("Green definition is missing or invalid.");
    }

     // --- Draw Tee Box --- (Simple rectangle for now)
     if (holeLayout.tee && holeLayout.tee.center && holeLayout.tee.surface) {
        const teeWidth = holeLayout.tee.width * scale;
        const teeDepth = holeLayout.tee.depth * scale;
        const teeHeight = holeLayout.tee.surface.height ?? 0.03; // Use defined height or fallback

        const teeGeometry = new THREE.PlaneGeometry(teeWidth, teeDepth);
        const teeMaterial = new THREE.MeshLambertMaterial({ // Use Lambert
            color: holeLayout.tee.surface.color, // Use specified surface color
            side: THREE.DoubleSide
        });
        const teeMesh = new THREE.Mesh(teeGeometry, teeMaterial);
        teeMesh.position.set(
            holeLayout.tee.center.x * scale,
            teeHeight, // Use defined height
            holeLayout.tee.center.z * scale
        );
        teeMesh.rotation.x = -Math.PI / 2;
        teeMesh.receiveShadow = true; // Tee should also receive shadows
        scene.add(teeMesh);
        currentHoleObjects.push(teeMesh);
    }


    // --- Draw Flagstick ---
    if (holeLayout.flagPosition) {
        const flagHeight = 2.5; // Meters
        const flagRadius = 0.05; // Meters
        const flagGeometry = new THREE.CylinderGeometry(flagRadius, flagRadius, flagHeight, 8);
        const flagMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff }); // White pole
        const flagstick = new THREE.Mesh(flagGeometry, flagMaterial);
        flagstick.position.set(
            holeLayout.flagPosition.x * scale,
            flagHeight / 2, // Position base at ground level (Y=0) relative to its center
            holeLayout.flagPosition.z * scale
        );
        flagstick.castShadow = true;
        scene.add(flagstick);
        currentHoleObjects.push(flagstick);

        // Store the flag position (base of the stick)
        currentFlagPosition = new THREE.Vector3(
            holeLayout.flagPosition.x * scale,
            0, // Assuming flag base is at y=0 world coordinate
            holeLayout.flagPosition.z * scale
        );
        console.log("Stored flag position (meters):", currentFlagPosition);


        // Optional: Add a little flag cloth
        const flagClothGeometry = new THREE.PlaneGeometry(0.5, 0.3);
        const flagClothMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide }); // Red flag
        const flagCloth = new THREE.Mesh(flagClothGeometry, flagClothMaterial);
        // Position relative to flagstick top
        flagCloth.position.set(
            flagstick.position.x + 0.25, // Offset slightly from pole
            flagstick.position.y + flagHeight / 2 - 0.15, // Near the top
            flagstick.position.z
        );
        scene.add(flagCloth);
        currentHoleObjects.push(flagCloth);

        // --- Draw the Hole Cup ---
        const HOLE_RADIUS_METERS = 0.108 / 2; // Regulation hole diameter is 4.25 inches (0.108m)
        const holeDepth = 0.1; // Depth for the visual cup (meters)
        const holeGeometry = new THREE.CylinderGeometry(HOLE_RADIUS_METERS, HOLE_RADIUS_METERS, holeDepth, 16);
        const holeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 }); // Black
        const holeMesh = new THREE.Mesh(holeGeometry, holeMaterial);
        holeMesh.renderOrder = 1; // Draw hole *after* the green

        // Position the hole centered at the flag position, top edge slightly below green surface
        const greenSurfaceY = currentGreenCenter ? currentGreenCenter.y : (holeLayout.green?.surface?.height ?? 0.02); // Get green height
        const holeTopEdgeY = greenSurfaceY - 0.005; // Place top slightly below green surface
        const holeCenterY = holeTopEdgeY - (holeDepth / 2); // Calculate center Y

        holeMesh.position.set(
            currentFlagPosition.x,
            holeCenterY, // Position cylinder center
            currentFlagPosition.z
        );
        // No rotation needed as cylinder is upright

        scene.add(holeMesh);
        currentHoleObjects.push(holeMesh);
    }

    console.log("Finished drawing hole layout. Added objects:", currentHoleObjects.length);
}

/**
 * Returns the stored position of the flagstick base in world coordinates (meters).
 * @returns {THREE.Vector3 | null} The flag position or null if not set.
 */
export function getFlagPosition() {
    return currentFlagPosition;
}

/**
 * Returns the stored center position of the green in world coordinates (meters).
 * @returns {THREE.Vector3 | null} The green center position or null if not set.
 */
export function getGreenCenter() {
    return currentGreenCenter;
}

/**
 * Returns the stored radius of the green in meters.
 * @returns {number | null} The green radius or null if not set.
 */
export function getGreenRadius() {
    return currentGreenRadius;
}
