// src/visuals/holeView.js
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js';
import { TextureLoader } from 'https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js'; // Import TextureLoader
// Removed noise import
import { scene, YARDS_TO_METERS } from './core.js'; // Import scene and conversion factor

let currentHoleObjects = []; // To keep track of objects added for the hole
let currentFlagPosition = null; // Store the flag position in meters (Vector3)
let currentGreenCenter = null; // Store the green center position in meters (Vector3)
let currentGreenRadius = null; // Store the green radius in meters (Number)

/**
 * Clears any previously drawn hole objects from the scene.
 */
export function clearHoleLayout() {
    if (!scene) return;
    currentHoleObjects.forEach(obj => {
        scene.remove(obj);
        if (obj.geometry) obj.geometry.dispose();
        if (obj.material) obj.material.dispose();
    });
    currentHoleObjects = [];
    console.log("Cleared previous hole layout visuals.");
}

/**
 * Draws the hole layout based on the provided data structure.
 * @param {object} holeLayout - The hole data generated by holeGenerator.js
 */
export function drawHoleLayout(holeLayout) {
    if (!scene || !holeLayout) {
        console.error("Scene not initialized or no hole layout provided for drawing.");
        return;
    }

    clearHoleLayout(); // Clear previous layout first
    currentFlagPosition = null; // Reset flag position on new draw
    currentGreenCenter = null; // Reset green data
    currentGreenRadius = null;
    console.log("Drawing hole layout:", holeLayout);

    const scale = YARDS_TO_METERS; // Use the conversion factor
    const textureLoader = new TextureLoader(); // Create texture loader instance

    // --- Draw Background (Out of Bounds - Draw first) ---
    if (holeLayout.background && holeLayout.background.vertices && holeLayout.background.surface) {
        const bgShape = new THREE.Shape();
        const firstBgPoint = holeLayout.background.vertices[0];
        // Use original Z
        bgShape.moveTo(firstBgPoint.x * scale, firstBgPoint.z * scale);
        for (let i = 1; i < holeLayout.background.vertices.length; i++) {
            const point = holeLayout.background.vertices[i];
             // Use original Z
            bgShape.lineTo(point.x * scale, point.z * scale);
        }
        bgShape.closePath();

        const bgGeometry = new THREE.ShapeGeometry(bgShape);
        // Geometry is created using world coordinates, no centering needed.

        const bgMaterial = new THREE.MeshLambertMaterial({
            color: holeLayout.background.surface.color,
            side: THREE.DoubleSide
        });
        const bgMesh = new THREE.Mesh(bgGeometry, bgMaterial);
        bgMesh.rotation.x = Math.PI / 2; // Positive rotation
        // Position mesh using surface height
        bgMesh.position.set(0, holeLayout.background.surface.height ?? -0.01, 0); // Use defined height or fallback
        bgMesh.receiveShadow = true; // Should still receive shadows
        scene.add(bgMesh);
        currentHoleObjects.push(bgMesh);
    }


    // --- Draw Rough (Draw on top of background) ---
    if (holeLayout.rough && holeLayout.rough.vertices && holeLayout.rough.surface) {
        // Define shape in XY plane (using Z as Y)
        const roughShape = new THREE.Shape();
        const firstRoughPoint = holeLayout.rough.vertices[0];
        // Use original Z
        roughShape.moveTo(firstRoughPoint.x * scale, firstRoughPoint.z * scale);

        for (let i = 1; i < holeLayout.rough.vertices.length; i++) {
            const point = holeLayout.rough.vertices[i];
             // Use original Z
            roughShape.lineTo(point.x * scale, point.z * scale);
        }
        roughShape.closePath(); // Use original ShapeGeometry

        const roughGeometry = new THREE.ShapeGeometry(roughShape);
        // --- BEGIN Manual UV Calculation ---
        roughGeometry.computeBoundingBox();
        const bbox = roughGeometry.boundingBox;
        if (bbox) { // Check if bounding box exists
            const positionAttribute = roughGeometry.attributes.position;
            const uvAttribute = new THREE.BufferAttribute(new Float32Array(positionAttribute.count * 2), 2);
            const sizeX = bbox.max.x - bbox.min.x;
            const sizeY = bbox.max.y - bbox.min.y; // Use Y size from XY plane

            if (sizeX > 0 && sizeY > 0) { // Avoid division by zero
                for (let i = 0; i < positionAttribute.count; i++) {
                    const x = positionAttribute.getX(i);
                    const y = positionAttribute.getY(i); // Use Y from ShapeGeometry's XY plane

                    const u = (x - bbox.min.x) / sizeX;
                    const v = (y - bbox.min.y) / sizeY;

                    uvAttribute.setXY(i, u, v);
                }
                roughGeometry.setAttribute('uv', uvAttribute);
                console.log("Manually calculated UVs for rough geometry.");
            } else {
                console.warn("Rough geometry has zero size in X or Y dimension, cannot calculate UVs.");
            }
        } else {
             console.warn("Could not compute bounding box for rough geometry.");
        }
        // --- END Manual UV Calculation ---
        // Geometry is created using world coordinates, no centering needed.

        // --- Rough Material (Texture or Color) ---
        const roughSurface = holeLayout.rough.surface;
        const roughMesh = new THREE.Mesh(roughGeometry); // Create mesh first
        roughMesh.rotation.x = Math.PI / 2; // Rotate ShapeGeometry like before
        roughMesh.position.set(0, roughSurface?.height ?? 0.0, 0); // Use defined height or fallback
        roughMesh.receiveShadow = true;

        if (roughSurface && roughSurface.texturePath) {
            textureLoader.load(
                roughSurface.texturePath,
                // onLoad callback
                (texture) => {
                    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                    // --- Simple Texture Repetition for Testing ---
                    const simpleRepetitions = 10; // Test value
                    texture.repeat.set(simpleRepetitions, simpleRepetitions);
                    console.log(`Rough Shape: Set simple texture repeat ${simpleRepetitions}x${simpleRepetitions}`);
                    // texture.needsUpdate = true; // Not needed when set before first render

                    roughMesh.material = new THREE.MeshStandardMaterial({ // Using StandardMaterial
                        map: texture,
                        side: THREE.DoubleSide
                        // vertexColors: false // Vertex colors removed
                    });
                    roughMesh.material.needsUpdate = true; // Important: update material when texture loads
                    console.log(`Texture ${roughSurface.texturePath} loaded and applied to rough.`);
                },
                // onProgress callback (optional)
                undefined,
                // onError callback
                (err) => {
                    console.error(`Error loading rough texture: ${roughSurface.texturePath}`, err);
                    // Fallback to color on error
                    roughMesh.material = new THREE.MeshStandardMaterial({ // Using StandardMaterial
                        color: roughSurface?.color || '#228b22',
                        side: THREE.DoubleSide
                        // vertexColors: false
                    });
                    roughMesh.material.needsUpdate = true;
                }
            );
        } else {
            // Apply color immediately if no texture path
            roughMesh.material = new THREE.MeshStandardMaterial({ // Using StandardMaterial
                color: roughSurface?.color || '#228b22', // Fallback color
                side: THREE.DoubleSide
                // vertexColors: false
            });
            console.log("Applied color to rough.");
        }
        scene.add(roughMesh); // Add mesh to scene (material will be applied async if texture loads)
        currentHoleObjects.push(roughMesh);
    }


    // --- Draw Water Hazards (On top of rough, below bunkers/fairway/green) ---
    if (holeLayout.waterHazards && Array.isArray(holeLayout.waterHazards)) {
        holeLayout.waterHazards.forEach(water => {
            if (!water || !water.surface) return; // Skip invalid water hazards

            const waterMaterial = new THREE.MeshLambertMaterial({
                color: water.surface.color,
                side: THREE.DoubleSide,
                transparent: true, // Make water slightly transparent
                opacity: 0.85
            });
            let waterGeometry;
            let waterMesh;
            const waterYOffset = water.surface.height ?? 0.002; // Use defined height or fallback

            if (water.type === 'circle' && water.center && water.radius) {
                const radiusMeters = water.radius * scale;
                const centerX = water.center.x * scale;
                const centerZ = water.center.z * scale;
                waterGeometry = new THREE.CircleGeometry(radiusMeters, 32);
                waterMesh = new THREE.Mesh(waterGeometry, waterMaterial);
                waterMesh.position.set(centerX, waterYOffset, centerZ);
                waterMesh.rotation.x = -Math.PI / 2;

            } else if (water.type === 'polygon' && water.vertices && water.vertices.length >= 3) {
                const waterShape = new THREE.Shape();
                const firstPoint = water.vertices[0];
                waterShape.moveTo(firstPoint.x * scale, firstPoint.z * scale);
                for (let i = 1; i < water.vertices.length; i++) {
                    const point = water.vertices[i];
                    waterShape.lineTo(point.x * scale, point.z * scale);
                }
                waterShape.closePath();
                waterGeometry = new THREE.ShapeGeometry(waterShape);
                waterMesh = new THREE.Mesh(waterGeometry, waterMaterial);
                waterMesh.position.set(0, waterYOffset, 0);
                waterMesh.rotation.x = Math.PI / 2;

            } else {
                console.warn("Skipping invalid water hazard definition:", water);
                return; // Skip this water hazard
            }

            waterMesh.receiveShadow = true; // Water can receive shadows
            scene.add(waterMesh);
            currentHoleObjects.push(waterMesh);
        });
    }

    // --- Draw Bunkers (On top of rough/water, below fairway/green) ---
    if (holeLayout.bunkers && Array.isArray(holeLayout.bunkers)) {
        holeLayout.bunkers.forEach(bunker => {
            if (!bunker || !bunker.surface) return; // Skip invalid bunkers

            const bunkerMaterial = new THREE.MeshLambertMaterial({
                color: bunker.surface.color,
                side: THREE.DoubleSide
            });
            let bunkerGeometry;
            let bunkerMesh;
            const bunkerYOffset = bunker.surface.height ?? 0.005; // Use defined height or fallback

            if (bunker.type === 'circle' && bunker.center && bunker.radius) {
                const radiusMeters = bunker.radius * scale;
                const centerX = bunker.center.x * scale;
                const centerZ = bunker.center.z * scale;
                bunkerGeometry = new THREE.CircleGeometry(radiusMeters, 32); // Use 32 segments for smoother circle
                bunkerMesh = new THREE.Mesh(bunkerGeometry, bunkerMaterial);
                bunkerMesh.position.set(centerX, bunkerYOffset, centerZ);
                bunkerMesh.rotation.x = -Math.PI / 2; // Rotate to lay flat

            } else if (bunker.type === 'polygon' && bunker.vertices && bunker.vertices.length >= 3) {
                const bunkerShape = new THREE.Shape();
                const firstPoint = bunker.vertices[0];
                bunkerShape.moveTo(firstPoint.x * scale, firstPoint.z * scale);
                for (let i = 1; i < bunker.vertices.length; i++) {
                    const point = bunker.vertices[i];
                    bunkerShape.lineTo(point.x * scale, point.z * scale);
                }
                bunkerShape.closePath();
                bunkerGeometry = new THREE.ShapeGeometry(bunkerShape);
                bunkerMesh = new THREE.Mesh(bunkerGeometry, bunkerMaterial);
                bunkerMesh.position.set(0, bunkerYOffset, 0); // Position at origin, geometry defines shape location
                bunkerMesh.rotation.x = Math.PI / 2; // Rotate to lay flat (like fairway/rough)

            } else {
                console.warn("Skipping invalid bunker definition:", bunker);
                return; // Skip this bunker
            }

            bunkerMesh.receiveShadow = true;
            scene.add(bunkerMesh);
            currentHoleObjects.push(bunkerMesh);
        });
    }


    // --- Draw Fairway (On top of rough/water/bunkers) ---
    if (holeLayout.fairway && holeLayout.fairway.vertices && holeLayout.fairway.surface) {
        // Define shape in XY plane (using Z as Y)
        const fairwayShape = new THREE.Shape();
        const firstPoint = holeLayout.fairway.vertices[0];
        // Use original coordinates
        fairwayShape.moveTo(firstPoint.x * scale, firstPoint.z * scale);
        for (let i = 1; i < holeLayout.fairway.vertices.length; i++) {
            const point = holeLayout.fairway.vertices[i];
             // Use original coordinates
            fairwayShape.lineTo(point.x * scale, point.z * scale);
        }
        fairwayShape.closePath();

        const fairwayGeometry = new THREE.ShapeGeometry(fairwayShape);
        // --- BEGIN Manual UV Calculation for Fairway ---
        fairwayGeometry.computeBoundingBox();
        const fairwayBbox = fairwayGeometry.boundingBox;
        if (fairwayBbox) {
            const positionAttribute = fairwayGeometry.attributes.position;
            const uvAttribute = new THREE.BufferAttribute(new Float32Array(positionAttribute.count * 2), 2);
            const sizeX = fairwayBbox.max.x - fairwayBbox.min.x;
            const sizeY = fairwayBbox.max.y - fairwayBbox.min.y;

            if (sizeX > 0 && sizeY > 0) {
                for (let i = 0; i < positionAttribute.count; i++) {
                    const x = positionAttribute.getX(i);
                    const y = positionAttribute.getY(i);
                    const u = (x - fairwayBbox.min.x) / sizeX;
                    const v = (y - fairwayBbox.min.y) / sizeY;
                    uvAttribute.setXY(i, u, v);
                }
                fairwayGeometry.setAttribute('uv', uvAttribute);
                console.log("Manually calculated UVs for fairway geometry.");
            } else {
                console.warn("Fairway geometry has zero size in X or Y dimension, cannot calculate UVs.");
            }
        } else {
            console.warn("Could not compute bounding box for fairway geometry.");
        }
        // --- END Manual UV Calculation for Fairway ---
        // Geometry is created using world coordinates, no centering needed.

        // --- Fairway Material (Texture or Color) ---
        const fairwaySurface = holeLayout.fairway.surface;
        const fairwayMesh = new THREE.Mesh(fairwayGeometry); // Create mesh first
        fairwayMesh.rotation.x = Math.PI / 2; // Positive rotation
        fairwayMesh.position.set(0, fairwaySurface?.height ?? 0.01, 0); // Use defined height or fallback
        fairwayMesh.receiveShadow = true;

        if (fairwaySurface && fairwaySurface.texturePath) {
             textureLoader.load(
                fairwaySurface.texturePath,
                // onLoad callback
                (texture) => {
                    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                    // Removed old repetition logic - manual UVs handle mapping
                    // const textureWorldSize = 10;
                    // fairwayGeometry.computeBoundingBox(); // Already computed for UVs
                    // const size = fairwayGeometry.boundingBox.getSize(new THREE.Vector3());
                    // texture.repeat.set(size.x / textureWorldSize, size.y / textureWorldSize);
                    const textureRepetitions = 15; // Adjust this value to control tiling density
                    texture.repeat.set(textureRepetitions, textureRepetitions);


                    fairwayMesh.material = new THREE.MeshStandardMaterial({ // Changed to StandardMaterial
                        map: texture,
                        side: THREE.DoubleSide
                    });
                    fairwayMesh.material.needsUpdate = true;
                    console.log(`Texture ${fairwaySurface.texturePath} loaded and applied to fairway.`);
                },
                 // onProgress callback (optional)
                undefined,
                // onError callback
                (err) => {
                    console.error(`Error loading fairway texture: ${fairwaySurface.texturePath}`, err);
                    // Fallback to color on error
                    fairwayMesh.material = new THREE.MeshStandardMaterial({ // Changed to StandardMaterial
                        color: fairwaySurface?.color || '#5DBB5D',
                        side: THREE.DoubleSide
                    });
                    fairwayMesh.material.needsUpdate = true;
                }
            );
        } else {
             // Apply color immediately if no texture path
            fairwayMesh.material = new THREE.MeshStandardMaterial({ // Changed to StandardMaterial
                color: fairwaySurface?.color || '#5DBB5D', // Fallback color
                side: THREE.DoubleSide
            });
            console.log("Applied color to fairway.");
        }
        scene.add(fairwayMesh); // Add mesh to scene
        currentHoleObjects.push(fairwayMesh);
    }

    // --- Draw Green --- (Now uses polygon logic)
    if (holeLayout.green && holeLayout.green.type === 'polygon' && holeLayout.green.vertices && holeLayout.green.vertices.length >= 3 && holeLayout.green.surface) {
        const greenHeight = holeLayout.green.surface.height ?? 0.02; // Use defined height or fallback

        const greenShape = new THREE.Shape();
        const firstPoint = holeLayout.green.vertices[0];
        greenShape.moveTo(firstPoint.x * scale, firstPoint.z * scale);
        for (let i = 1; i < holeLayout.green.vertices.length; i++) {
            const point = holeLayout.green.vertices[i];
            greenShape.lineTo(point.x * scale, point.z * scale);
        }
        greenShape.closePath();

        const greenGeometry = new THREE.ShapeGeometry(greenShape);
        // --- BEGIN Manual UV Calculation for Green ---
        greenGeometry.computeBoundingBox();
        const greenBbox = greenGeometry.boundingBox;
        if (greenBbox) {
            const positionAttribute = greenGeometry.attributes.position;
            const uvAttribute = new THREE.BufferAttribute(new Float32Array(positionAttribute.count * 2), 2);
            const sizeX = greenBbox.max.x - greenBbox.min.x;
            const sizeY = greenBbox.max.y - greenBbox.min.y;

            if (sizeX > 0 && sizeY > 0) {
                for (let i = 0; i < positionAttribute.count; i++) {
                    const x = positionAttribute.getX(i);
                    const y = positionAttribute.getY(i);
                    const u = (x - greenBbox.min.x) / sizeX;
                    const v = (y - greenBbox.min.y) / sizeY;
                    uvAttribute.setXY(i, u, v);
                }
                greenGeometry.setAttribute('uv', uvAttribute);
                console.log("Manually calculated UVs for green geometry.");
            } else {
                console.warn("Green geometry has zero size in X or Y dimension, cannot calculate UVs.");
            }
        } else {
            console.warn("Could not compute bounding box for green geometry.");
        }
        // --- END Manual UV Calculation for Green ---
        // --- Green Material (Texture or Color) ---
        const greenSurface = holeLayout.green.surface;
        const greenMesh = new THREE.Mesh(greenGeometry); // Create mesh first
        greenMesh.rotation.x = Math.PI / 2; // Rotate polygon to lay flat like fairway/rough
        greenMesh.position.set(0, greenHeight, 0); // Position mesh using surface height
        greenMesh.receiveShadow = true;

         if (greenSurface && greenSurface.texturePath) {
             textureLoader.load(
                greenSurface.texturePath,
                // onLoad callback
                (texture) => {
                    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                    // Removed old repetition logic - manual UVs handle mapping
                    // const textureWorldSize = 4;
                    // greenGeometry.computeBoundingBox(); // Already computed for UVs
                    // const size = greenGeometry.boundingBox.getSize(new THREE.Vector3());
                    // texture.repeat.set(size.x / textureWorldSize, size.y / textureWorldSize);
                    const textureRepetitions = 10; // Adjust this value to control tiling density
                    texture.repeat.set(textureRepetitions, textureRepetitions);


                    greenMesh.material = new THREE.MeshStandardMaterial({ // Changed to StandardMaterial
                        map: texture,
                        side: THREE.DoubleSide
                    });
                    greenMesh.material.needsUpdate = true;
                    console.log(`Texture ${greenSurface.texturePath} loaded and applied to green.`);
                },
                 // onProgress callback (optional)
                undefined,
                // onError callback
                (err) => {
                    console.error(`Error loading green texture: ${greenSurface.texturePath}`, err);
                    // Fallback to color on error
                    greenMesh.material = new THREE.MeshStandardMaterial({ // Changed to StandardMaterial
                        color: greenSurface?.color || '#3A9A3A',
                        side: THREE.DoubleSide
                    });
                    greenMesh.material.needsUpdate = true;
                }
            );
        } else {
             // Apply color immediately if no texture path
            greenMesh.material = new THREE.MeshStandardMaterial({ // Changed to StandardMaterial
                color: greenSurface?.color || '#3A9A3A', // Fallback color
                side: THREE.DoubleSide
            });
            console.log("Applied color to green.");
        }
        scene.add(greenMesh); // Add mesh to scene
        currentHoleObjects.push(greenMesh);

        // TODO: Revisit how to store green center/radius for polygon shapes if needed later
        // For now, reset them as the old circle logic is gone.
        currentGreenCenter = null;
        currentGreenRadius = null;
        console.log(`Drawn polygon green at height ${greenHeight.toFixed(3)}`);

    } else if (holeLayout.green && holeLayout.green.center && holeLayout.green.radius) {
         // Fallback for old circle definition (optional, can be removed later)
         console.warn("Drawing green using legacy circle definition.");
         const greenRadiusMeters = holeLayout.green.radius * scale;
         const greenCenterX = holeLayout.green.center.x * scale;
         const greenCenterZ = holeLayout.green.center.z * scale;
         const greenHeight = holeLayout.green.surface?.height ?? 0.02;
         const greenGeometry = new THREE.CircleGeometry(greenRadiusMeters, 64);
         const greenMaterial = new THREE.MeshLambertMaterial({ color: holeLayout.green.surface?.color || '#3A9A3A', side: THREE.DoubleSide });
         const greenMesh = new THREE.Mesh(greenGeometry, greenMaterial);
         greenMesh.position.set(greenCenterX, greenHeight, greenCenterZ);
         greenMesh.rotation.x = -Math.PI / 2;
         greenMesh.receiveShadow = true;
         scene.add(greenMesh);
         currentHoleObjects.push(greenMesh);
         currentGreenCenter = new THREE.Vector3(greenCenterX, greenHeight, greenCenterZ);
         currentGreenRadius = greenRadiusMeters;
    } else {
        console.warn("Green definition is missing or invalid.");
    }

     // --- Draw Tee Box --- (Simple rectangle for now)
     if (holeLayout.tee && holeLayout.tee.center && holeLayout.tee.surface) {
        const teeWidth = holeLayout.tee.width * scale;
        const teeDepth = holeLayout.tee.depth * scale;
        const teeHeight = holeLayout.tee.surface.height ?? 0.03; // Use defined height or fallback

        const teeGeometry = new THREE.PlaneGeometry(teeWidth, teeDepth);
        const teeMaterial = new THREE.MeshLambertMaterial({ // Use Lambert
            color: holeLayout.tee.surface.color, // Use specified surface color
            side: THREE.DoubleSide
        });
        const teeMesh = new THREE.Mesh(teeGeometry, teeMaterial);
        teeMesh.position.set(
            holeLayout.tee.center.x * scale,
            teeHeight, // Use defined height
            holeLayout.tee.center.z * scale
        );
        teeMesh.rotation.x = -Math.PI / 2;
        teeMesh.receiveShadow = true; // Tee should also receive shadows
        scene.add(teeMesh);
        currentHoleObjects.push(teeMesh);
    }


    // --- Draw Flagstick ---
    if (holeLayout.flagPosition) {
        const flagHeight = 2.5; // Meters
        const flagRadius = 0.05; // Meters
        const flagGeometry = new THREE.CylinderGeometry(flagRadius, flagRadius, flagHeight, 8);
        const flagMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff }); // White pole
        const flagstick = new THREE.Mesh(flagGeometry, flagMaterial);
        flagstick.position.set(
            holeLayout.flagPosition.x * scale,
            flagHeight / 2, // Position base at ground level (Y=0) relative to its center
            holeLayout.flagPosition.z * scale
        );
        flagstick.castShadow = true;
        scene.add(flagstick);
        currentHoleObjects.push(flagstick);

        // Store the flag position (base of the stick)
        currentFlagPosition = new THREE.Vector3(
            holeLayout.flagPosition.x * scale,
            0, // Assuming flag base is at y=0 world coordinate
            holeLayout.flagPosition.z * scale
        );
        console.log("Stored flag position (meters):", currentFlagPosition);


        // Optional: Add a little flag cloth
        const flagClothGeometry = new THREE.PlaneGeometry(0.5, 0.3);
        const flagClothMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide }); // Red flag
        const flagCloth = new THREE.Mesh(flagClothGeometry, flagClothMaterial);
        // Position relative to flagstick top
        flagCloth.position.set(
            flagstick.position.x + 0.25, // Offset slightly from pole
            flagstick.position.y + flagHeight / 2 - 0.15, // Near the top
            flagstick.position.z
        );
        scene.add(flagCloth);
        currentHoleObjects.push(flagCloth);

        // --- Draw the Hole Cup ---
        const HOLE_RADIUS_METERS = 0.108 / 2; // Regulation hole diameter is 4.25 inches (0.108m)
        const holeDepth = 0.1; // Depth for the visual cup (meters)
        const holeGeometry = new THREE.CylinderGeometry(HOLE_RADIUS_METERS, HOLE_RADIUS_METERS, holeDepth, 16);
        const holeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 }); // Black
        const holeMesh = new THREE.Mesh(holeGeometry, holeMaterial);
        holeMesh.renderOrder = 1; // Draw hole *after* the green

        // Position the hole centered at the flag position, top edge slightly below green surface
        const greenSurfaceY = currentGreenCenter ? currentGreenCenter.y : (holeLayout.green?.surface?.height ?? 0.02); // Get green height
        const holeTopEdgeY = greenSurfaceY - 0.005; // Place top slightly below green surface
        const holeCenterY = holeTopEdgeY - (holeDepth / 2); // Calculate center Y

        holeMesh.position.set(
            currentFlagPosition.x,
            holeCenterY, // Position cylinder center
            currentFlagPosition.z
        );
        // No rotation needed as cylinder is upright

        scene.add(holeMesh);
        currentHoleObjects.push(holeMesh);
    }

    console.log("Finished drawing hole layout. Added objects:", currentHoleObjects.length);
}

/**
 * Returns the stored position of the flagstick base in world coordinates (meters).
 * @returns {THREE.Vector3 | null} The flag position or null if not set.
 */
export function getFlagPosition() {
    return currentFlagPosition;
}

/**
 * Returns the stored center position of the green in world coordinates (meters).
 * @returns {THREE.Vector3 | null} The green center position or null if not set.
 */
export function getGreenCenter() {
    return currentGreenCenter;
}

/**
 * Returns the stored radius of the green in meters.
 * @returns {number | null} The green radius or null if not set.
 */
export function getGreenRadius() {
    return currentGreenRadius;
}
