// src/visuals/holeView.js
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js';
import { scene, YARDS_TO_METERS } from './core.js'; // Import scene and conversion factor

let currentHoleObjects = []; // To keep track of objects added for the hole
let currentFlagPosition = null; // Store the flag position in meters (Vector3)
let currentGreenCenter = null; // Store the green center position in meters (Vector3)
let currentGreenRadius = null; // Store the green radius in meters (Number)

/**
 * Clears any previously drawn hole objects from the scene.
 */
export function clearHoleLayout() {
    if (!scene) return;
    currentHoleObjects.forEach(obj => {
        scene.remove(obj);
        if (obj.geometry) obj.geometry.dispose();
        if (obj.material) obj.material.dispose();
    });
    currentHoleObjects = [];
    console.log("Cleared previous hole layout visuals.");
}

/**
 * Draws the hole layout based on the provided data structure.
 * @param {object} holeLayout - The hole data generated by holeGenerator.js
 */
export function drawHoleLayout(holeLayout) {
    if (!scene || !holeLayout) {
        console.error("Scene not initialized or no hole layout provided for drawing.");
        return;
    }

    clearHoleLayout(); // Clear previous layout first
    currentFlagPosition = null; // Reset flag position on new draw
    currentGreenCenter = null; // Reset green data
    currentGreenRadius = null;
    console.log("Drawing hole layout:", holeLayout);

    const scale = YARDS_TO_METERS; // Use the conversion factor

    // --- Draw Rough (Draw first as the base layer) ---
    if (holeLayout.rough && holeLayout.rough.vertices) {
        // Define shape in XY plane (using Z as Y)
        const roughShape = new THREE.Shape();
        const firstRoughPoint = holeLayout.rough.vertices[0];
        roughShape.moveTo(firstRoughPoint.x * scale, firstRoughPoint.z * scale); // Use z as y
        for (let i = 1; i < holeLayout.rough.vertices.length; i++) {
            const point = holeLayout.rough.vertices[i];
            roughShape.lineTo(point.x * scale, point.z * scale); // Use z as y
        }
        roughShape.closePath();

        const roughGeometry = new THREE.ShapeGeometry(roughShape);
        // Calculate geometry center (based on original Z range) for translation
        // Assuming rectangular rough defined by min/max Z from vertices
        const roughZs = holeLayout.rough.vertices.map(v => v.z * scale);
        const roughMinZ = Math.min(...roughZs);
        const roughMaxZ = Math.max(...roughZs);
        const roughLength = roughMaxZ - roughMinZ;
        roughGeometry.translate(0, -(roughMinZ + roughLength / 2), 0); // Translate geometry origin to center Y

        const roughMaterial = new THREE.MeshLambertMaterial({
            color: holeLayout.rough.surface.color,
            side: THREE.DoubleSide
        });
        const roughMesh = new THREE.Mesh(roughGeometry, roughMaterial);
        roughMesh.rotation.x = -Math.PI / 2; // Rotate mesh
        // Position mesh center in world space
        roughMesh.position.set(0, 0.0, (roughMinZ + roughMaxZ) / 2);
        roughMesh.receiveShadow = true;
        scene.add(roughMesh);
        currentHoleObjects.push(roughMesh);
    }

    // --- Draw Fairway (On top of rough) ---
    if (holeLayout.fairway && holeLayout.fairway.vertices) {
        // Define shape in XY plane (using Z as Y)
        const fairwayShape = new THREE.Shape();
        const firstPoint = holeLayout.fairway.vertices[0];
        fairwayShape.moveTo(firstPoint.x * scale, firstPoint.z * scale); // Use z as y
        for (let i = 1; i < holeLayout.fairway.vertices.length; i++) {
            const point = holeLayout.fairway.vertices[i];
            fairwayShape.lineTo(point.x * scale, point.z * scale); // Use z as y
        }
        fairwayShape.closePath();

        const fairwayGeometry = new THREE.ShapeGeometry(fairwayShape);
        // Calculate geometry center (based on original Z range) for translation
        const fairwayZs = holeLayout.fairway.vertices.map(v => v.z * scale);
        const fairwayMinZ = Math.min(...fairwayZs);
        const fairwayMaxZ = Math.max(...fairwayZs);
        const fairwayLength = fairwayMaxZ - fairwayMinZ;
        fairwayGeometry.translate(0, -(fairwayMinZ + fairwayLength / 2), 0); // Translate geometry origin to center Y

        const fairwayMaterial = new THREE.MeshLambertMaterial({
            color: holeLayout.fairway.surface.color,
            side: THREE.DoubleSide
        });
        const fairwayMesh = new THREE.Mesh(fairwayGeometry, fairwayMaterial);
        fairwayMesh.rotation.x = -Math.PI / 2; // Rotate mesh
        // Position mesh center in world space, slightly above rough
        fairwayMesh.position.set(0, 0.01, (fairwayMinZ + fairwayMaxZ) / 2);
        fairwayMesh.receiveShadow = true;
        scene.add(fairwayMesh);
        currentHoleObjects.push(fairwayMesh);
    }

    // --- Draw Green ---
    if (holeLayout.green && holeLayout.green.center && holeLayout.green.radius) {
        const greenRadiusMeters = holeLayout.green.radius * scale;
        const greenCenterX = holeLayout.green.center.x * scale;
        const greenCenterZ = holeLayout.green.center.z * scale;

        const greenGeometry = new THREE.CircleGeometry(greenRadiusMeters, 64);
        const greenMaterial = new THREE.MeshLambertMaterial({ // Use Lambert
            color: holeLayout.green.surface.color,
            side: THREE.DoubleSide
        });
        const greenMesh = new THREE.Mesh(greenGeometry, greenMaterial);
        greenMesh.position.set(
            greenCenterX,
            0.02, // Small offset like targetView
            greenCenterZ
        );
        greenMesh.rotation.x = -Math.PI / 2;
        greenMesh.receiveShadow = true;
        scene.add(greenMesh);
        currentHoleObjects.push(greenMesh);

        // Store green data
        currentGreenCenter = new THREE.Vector3(greenCenterX, 0.02, greenCenterZ); // Store the mesh position
        currentGreenRadius = greenRadiusMeters;
        console.log(`Stored green data: Center=${currentGreenCenter.z.toFixed(1)}, Radius=${currentGreenRadius.toFixed(1)}`);
    }

     // --- Draw Tee Box --- (Simple rectangle for now)
     if (holeLayout.tee && holeLayout.tee.center) {
        const teeWidth = holeLayout.tee.width * scale;
        const teeDepth = holeLayout.tee.depth * scale;
        const teeGeometry = new THREE.PlaneGeometry(teeWidth, teeDepth);
        const teeMaterial = new THREE.MeshLambertMaterial({ // Use Lambert
            color: holeLayout.tee.surface.color, // Use specified surface color
            side: THREE.DoubleSide
        });
        const teeMesh = new THREE.Mesh(teeGeometry, teeMaterial);
        teeMesh.position.set(
            holeLayout.tee.center.x * scale,
            0.03, // Small offset above green
            holeLayout.tee.center.z * scale
        );
        teeMesh.rotation.x = -Math.PI / 2;
        teeMesh.receiveShadow = true; // Tee should also receive shadows
        scene.add(teeMesh);
        currentHoleObjects.push(teeMesh);
    }


    // --- Draw Flagstick ---
    if (holeLayout.flagPosition) {
        const flagHeight = 2.5; // Meters
        const flagRadius = 0.05; // Meters
        const flagGeometry = new THREE.CylinderGeometry(flagRadius, flagRadius, flagHeight, 8);
        const flagMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff }); // White pole
        const flagstick = new THREE.Mesh(flagGeometry, flagMaterial);
        flagstick.position.set(
            holeLayout.flagPosition.x * scale,
            flagHeight / 2, // Position base at ground level
            holeLayout.flagPosition.z * scale
        );
        flagstick.castShadow = true;
        scene.add(flagstick);
        currentHoleObjects.push(flagstick);

        // Store the flag position (base of the stick)
        currentFlagPosition = new THREE.Vector3(
            holeLayout.flagPosition.x * scale,
            0, // Assuming flag base is at y=0
            holeLayout.flagPosition.z * scale
        );
        console.log("Stored flag position (meters):", currentFlagPosition);


        // Optional: Add a little flag cloth
        const flagClothGeometry = new THREE.PlaneGeometry(0.5, 0.3);
        const flagClothMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide }); // Red flag
        const flagCloth = new THREE.Mesh(flagClothGeometry, flagClothMaterial);
        flagCloth.position.set(
            holeLayout.flagPosition.x * scale + 0.25, // Offset slightly from pole
            flagHeight - 0.15, // Near the top
            holeLayout.flagPosition.z * scale
        );
        scene.add(flagCloth);
        currentHoleObjects.push(flagCloth);
    }

    console.log("Finished drawing hole layout. Added objects:", currentHoleObjects.length);
}

/**
 * Returns the stored position of the flagstick base in world coordinates (meters).
 * @returns {THREE.Vector3 | null} The flag position or null if not set.
 */
export function getFlagPosition() {
    return currentFlagPosition;
}

/**
 * Returns the stored center position of the green in world coordinates (meters).
 * @returns {THREE.Vector3 | null} The green center position or null if not set.
 */
export function getGreenCenter() {
    return currentGreenCenter;
}

/**
 * Returns the stored radius of the green in meters.
 * @returns {number | null} The green radius or null if not set.
 */
export function getGreenRadius() {
    return currentGreenRadius;
}
